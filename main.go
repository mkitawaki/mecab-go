package main

import (
	"fmt"
	m "github.com/mkitawaki/mecab-go/mecab"
	"os"
)

func check(err error, tagger *m.Tagger) {
	if err != nil {
		str := tagger.StrError()
		fmt.Printf("\nException:%s", str)
		tagger.Destroy()
		os.Exit(-1)
	}
}

func main() {
	var (
		model   *m.Model
		tagger  *m.Tagger
		lattice *m.Lattice
		success int
		str     string
		err     error
	)

	input := "太郎は次郎が持っている本を花子に渡した。"

	// Create model objcet
	model, _ = m.NewModel2("")

	// Create Tagger
	// All taggers generated by Model::createTagger() method share
	// the same model/dictoinary
	tagger, _ = model.CreateTagger()

	// Create lattice object per thread
	lattice, err = model.CreateLattice()
	check(err, tagger)

	// Gets tagged result in string
	lattice.SetSentence(input)

	// this method is thread safe, as long as |lattice| is thread local
	success = tagger.ParseLattice(lattice)
	//check(tagger, tagger)
	str = lattice.ToStr()
	fmt.Printf("\n%s\n", str)

	// Gets node object
	node, err := lattice.BosNode()
	check(err, tagger)

	for ; err == nil; node, err = node.Next() {
		id := node.Id()
		fmt.Printf("%d", id)
		n := node.Stat()
		if n == m.MECAB_BOS_NODE {
			fmt.Printf("BOS")
		} else if n == m.MECAB_EOS_NODE {
			fmt.Printf("EOS")
		} else {
			s := node.Surface()
			l := node.Length()
			fmt.Printf("%s", s[:l])
		}
		f := node.Feature()
		s := node.Surface()
		l := node.Length()
		fmt.Printf(" %s %d %d %d %d %d %d %d %d %f %f %f %d\n",
			f,
			(int)(len(input)-len(s)),
			(int)(len(input)-len(s)+(int)(l)),
			node.RcAttr(),
			node.LcAttr(),
			node.Posid(),
			node.CharType(),
			node.Stat(),
			node.Isbest(),
			node.Alpha(),
			node.Beta(),
			node.Prob(),
			node.Cost())
	}
	//begin_nodes/end_nodes
	l := lattice.GetSize()
	for i := 0; i <= int(l); i = i + 1 {
		b, err := lattice.GetBeginNodes(uint64(i))
		e, err := lattice.GetEndNodes(uint64(i))
		for ; err == nil; b, err = b.Bnext() {
			s := b.Surface()
			f := b.Feature()
			fmt.Printf("B[%d] %s\t%s\n", i, s, f)
		}
		for ; err == nil; e, err = e.Enext() {
			s := e.Surface()
			f := e.Feature()
			fmt.Printf("E[%d] %s\t%s\n", i, s, f)
		}
	}

	//N best results
	lattice.SetRequestType(m.MECAB_NBEST)
	lattice.SetSentence(input)
	success = tagger.ParseLattice(lattice)
	for i := 0; i < 10; i = i + 1 {
		fmt.Printf("NBEST:%d\n", i)
		str = lattice.ToStr()
		fmt.Printf("%s", str)
		success = lattice.Next()
		if success == 0 {
			// No more results
			break
		}
	}

	// Marginal probabilities
	lattice.SetSentence(input)
	lattice.SetRequestType(m.MECAB_MARGINAL_PROB)
	lattice.SetTheta(0.001)
	tagger.ParseLattice(lattice)
	node, err = lattice.BosNode()
	check(err, tagger)
	for ; err != nil; node, err = node.Next() {
		fmt.Printf(node.Surface()[:node.Length()])
		fmt.Printf("\t%s\n", node.Feature())
	}
	//		lattice.RemoveRequestType(MECAB_NBEST)
	tagger.SetLatticeLevel(0)
	tagger.SetAllMorphs(1)
	node, err = tagger.SparseTonode(input)
	check(err, tagger)
	for ; err != nil; node, err = node.Next() {
		fmt.Printf(node.Surface()[:node.Length()])
		fmt.Printf("\t%s\n", node.Feature())
	}

	// Dictionary info
	d, err := tagger.DictionaryInfo()
	for ; err != nil; d, err = d.Next() {
		fmt.Printf("filename: %s\n", d.Filename())
		fmt.Printf("charset: %s\n", d.Charset())
		fmt.Printf("size: %d\n", d.Size())
		fmt.Printf("type: %d\n", d.Type())
		fmt.Printf("lsize: %d\n", d.Lsize())
		fmt.Printf("rsize: %d\n", d.Rsize())
		fmt.Printf("version: %d\n", d.Version())
	}

	tagger.Destroy()
	lattice.Destroy()
	model.Destroy()
}
